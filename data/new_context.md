# Контекст проекта: TG Market Parser

> Этот файл предназначен для восстановления контекста при продолжении работы над проектом с AI-ассистентом.

---

## Суть проекта

Парсер торгового Telegram-чата игры **Epsilion War** ("Торговля. Epsilion War", ID: 1250973291).  
Цель — автоматически собирать рыночные данные, анализировать цены и предоставлять API для мониторинга.

---

## Технический стек

- **PHP 8.1+**, **Laravel 10**
- **MadelineProto** (danog/madelineproto ^8.0) — для авторизации и загрузки сообщений из Telegram
- **MySQL** — два экземпляра: `telegram_parser` (наши данные) и `telegram_session` (сессии MadelineProto)
- **Hetzner CX32** — сервер развёртывания (32 CPU, 64GB RAM)

---

## Архитектурные решения (и причины)

### Почему Laravel, а не чистый PHP
MadelineProto работает как обычная Composer-библиотека. Выбрали Laravel за миграции, Eloquent, Queue, Scheduling и удобную структуру. Artisan-команда `telegram:fetch` запускается через cron.

### Почему две базы данных
MadelineProto создаёт свои таблицы автоматически. Изолировали их в `telegram_session`, чтобы не смешивать с нашими данными в `telegram_parser`.

### Почему parent_id в products, а не отдельная таблица синонимов
Self-referencing проще в запросах (`COALESCE(parent_id, id)`), достаточно для наших нужд. Отдельная таблица синонимов была бы избыточной.

### Почему products и services разделены
Товары и услуги — принципиально разные сущности. Смешивать в одной таблице = каша в данных и отчётах.

### Почему exchanges — отдельная таблица
Обмен — это две стороны (товар А ↔ товар Б), не укладывается в модель listings с одним product_id. Плюс доплаты с направлением (кто доплачивает).

---

## Структура данных (таблицы)

```
telegram_parser:
  tg_users          — пользователи чата
  products          — справочник товаров (parent_id для алиасов, icon для иконок)
  services          — справочник услуг и найма (аналогично products)
  tg_messages       — сырые сообщения (raw_text, tg_link, sent_at, is_parsed)
  listings          — объявления buy/sell товаров (price, currency, status, anomaly_reason)
  service_listings  — объявления услуг/найма (offer/wanted)
  exchanges         — обмены товарами (product↔exchange_product, surcharge)

telegram_session:
  [таблицы MadelineProto — не трогать]
```

---

## Логика парсинга

### Типы объявлений (определяются из хэштегов или ключевых слов)

| Тип | Хэштеги | Ключевые слова |
|-----|---------|----------------|
| `sell` | #продам, #продаю, #продажа, #sell | продам, продаю |
| `buy` | #куплю, #скупка, #скуплю, #скупаю, #buy, #ищу | куплю, покупаю, скупаю |
| `trade` | #обмен, #обменяю, #меняю, #мен | обменяю, меняю |
| `service` | #услуги, #услуга, #крафтер, #алхимик, #заточки, #найму, #найм | предлагаю услуги |

### Одно сообщение может содержать несколько секций
Например: `#продам ... #куплю ... #обмен ...` — из одного сообщения создаётся несколько listings и exchanges.

### Валюты
- 💰 = `gold` (основная)
- 🍪 = `cookie` (вторая)
- Цены с пробелами внутри числа: `3 300💰` → 3300

### Товары
- Иконка = эмодзи в начале строки (может быть несколько: `🌡🎆`)
- Название = текст после иконки до тире/цены
- Поиск по `normalized_name` (без эмодзи, lowercase)
- Если товар уже есть в БД с иконкой, а в новом объявлении без иконки — сохраняем иконку из БД

---

## Аномалии цен

- Порог: `PRICE_ANOMALY_THRESHOLD` в `.env` (по умолчанию 50%)
- Период для расчёта среднего: `PRICE_ANOMALY_DAYS` (по умолчанию 7 дней)
- Минимум записей для расчёта: 3 (иначе — недостаточно данных, статус `ok`)
- Статусы: `ok`, `suspicious`, `needs_review`, `invalid`
- `invalid` исключается из всех расчётов цен

---

## API

`GET /api/market` — рыночные данные за последние N дней.

Параметры: `format=json|html`, `currency=gold|cookie`, `product_id=1,2,3`, `days=30`

Возвращает на каждый товар:
- Максимальная цена покупки + кто покупает (ссылка на профиль TG) + дата (ссылка на сообщение)
- Минимальная цена продажи + кто продаёт + дата

---

## Что ещё планируется

1. **Сидеры с начальными данными** — запустить парсер на имеющемся JSON-экспорте, получить реальные товары/цены → оформить в CSV/сидеры
2. **Ежедневный отчёт** — `GET /api/market/report?date=2026-02-17`
3. **Сравнение дат** — `GET /api/market/compare?date1=...&date2=...`
4. **История цен** — `GET /api/market/history?product_id=5`
5. **Список аномалий** — `GET /api/market/anomalies`
6. **CSV экспорт** начальных данных (products, users, prices) из JSON-экспорта

---

## Исходные данные

Имеется JSON-экспорт чата: 31 521 сообщение за период 2026-01-17 — 2026-02-17.  
Формат: стандартный экспорт Telegram Desktop (result.json).  
Чат: "Торговля. Epsilion War", public_supergroup, ID: 1250973291.

---

## Файлы проекта

```
app/Services/MessageParser.php          — парсинг текста
app/Services/MessageSaver.php           — сохранение в БД
app/Services/TelegramFetcher.php        — загрузка через MadelineProto
app/Services/PriceAnomalyDetector.php   — детектирование аномалий
app/Http/Controllers/MarketController.php — API
app/Console/Commands/FetchTelegramMessages.php — Artisan команда
config/parser.php                       — все настройки
database/migrations/                    — 7 миграций
tests/Unit/MessageParserTest.php        — юнит-тесты парсера
tests/Feature/MarketControllerTest.php  — feature-тесты API
docs/README.md                          — быстрый старт
docs/DATABASE.md                        — схема БД
docs/API.md                             — документация API
docs/CONTEXT.md                         — этот файл
```

---

## Поле `is_verified` в таблице `products`

Флаг для администратора — подтверждено ли что товар реально существует в игровой базе данных и что название, грейд и иконка соответствуют игровым данным.

| Значение | Смысл |
|----------|-------|
| `false` | Товар создан автоматически парсером, администратор ещё не сверял с игровой БД |
| `true` | Администратор вручную проверил — название, грейд и иконка совпадают с игрой |

**Важно:**
- В API и отчётах `is_verified` **не влияет** на выдачу — показываем все товары со статусом `ok` независимо от флага
- `is_verified` — исключительно внутренний инструмент для администратора
- В Filament отображается как индикатор (зелёный/серый) в таблице товаров, с действием "Подтвердить" / "Снять подтверждение"
- **Сейчас по умолчанию `is_verified = false`** для всех товаров включая загружаемые через сидеры — ничего ещё не проверено
- **В будущем** когда будет готов "заапрувленный" CSV с проверенными товарами — при импорте через сидер выставлять `is_verified = true` сразу. Это отдельная задача, реализуется позже.

**TODO в коде:** добавить поле `is_verified` (boolean, default false) в миграцию `products` и в Filament Resource.

---

## Административная панель

Необходим веб-интерфейс для ручной модерации данных. Авторизация — простая, один администратор.

### Раздел 1 — Очередь товаров (`products_pending`)

Таблица с фильтрами по статусу. Для каждой записи:

| Статус | Что показываем | Действия |
|--------|---------------|----------|
| `new` | Название, иконка, грейд, ссылка на сообщение | Подтвердить / Назначить алиасом (выбрать parent) / Удалить |
| `icon_conflict` | Текущая иконка в БД vs иконка из объявления | Оставить текущую / Заменить на новую |
| `grade_conflict` | Текущий грейд в БД vs грейд из объявления | Оставить текущий / Заменить на новый |
| `missing_icon` | Товар без иконки, ссылка на сообщение | Ввести иконку вручную / Пропустить |
| `missing_grade` | Товар без грейда, ссылка на сообщение | Выбрать грейд из списка / Пропустить |

**Во всех случаях** рядом с записью показывается **полный текст исходного объявления** (`tg_messages.raw_text`) — чтобы администратор видел контекст и мог принять правильное решение. Ссылка на оригинальное сообщение в Telegram также присутствует.

### Раздел 2 — Аномальные цены (`listings` со статусом `suspicious`)

Таблица аномальных цен. Для каждой записи показываем:
- Товар (иконка + название + грейд)
- Цена из объявления
- Средняя цена за период (для сравнения)
- Процент отклонения
- Автор объявления (ссылка на TG)
- Ссылка на сообщение в TG
- Дата
- **Полный текст исходного объявления** (`tg_messages.raw_text`)

Действия: Подтвердить как норму (`ok`) / Пометить как ошибку парсинга (`invalid`)

### Технический стек админки

**Выбран Filament** — готовая Laravel-админка, минимум кода, из коробки таблицы с фильтрами, формы, actions.

Установка: `composer require filament/filament` + `php artisan filament:install --panels`

**TODO:**
- Добавить `filament/filament` в `composer.json`
- Создать Filament Resource для `ProductPending` (таблица с фильтром по статусу, actions для каждого статуса)
- Создать Filament Resource для `Listing` с фильтром `status = suspicious`
- Авторизация — стандартный Laravel Auth, один пользователь-администратор создаётся через seeder или `php artisan make:filament-user`

---

## Стратегия поиска товара при импорте

При парсинге нового объявления для поиска существующего товара в `products` использовать **многоуровневый матчинг**:

**Уровень 1 — Точное совпадение** `normalized_name` + `grade` → нашли, используем.

**Уровень 2 — Совпадение по префиксу** первые 10-20 символов `normalized_name` → получаем кандидатов, выбираем наиболее похожего (например по расстоянию Левенштейна или просто наибольшее совпадение символов).

**Уровень 3 — Не нашли** → кладём в `products_pending` со статусом `new`.

**Зачем префикс:** большинство мусорных записей появляется из-за того что парсер не до конца вычистил строку — остались остатки цены, количества, скобки. Но начало названия как правило чистое. Например:
- `безопасный свиток заточки` ← чистое
- `безопасный свиток заточки - /шт (оптом цена ниже)` ← мусор в хвосте
- `безопасный свиток заточки 3шт по` ← мусор в хвосте

Первые 15 символов `безопасный сви` совпадают во всех трёх — можно найти правильный товар и не плодить дубли.

**TODO в коде:** в методе `Product::findOrQueue()` реализовать двухэтапный поиск:
```php
// Шаг 1: точный поиск
$product = Product::where('normalized_name', $normalized)->where('grade', $grade)->first();

// Шаг 2: поиск по префиксу (первые 15 символов)
if (!$product) {
    $prefix = mb_substr($normalized, 0, 15);
    $candidates = Product::where('normalized_name', 'LIKE', $prefix . '%')
        ->where('grade', $grade)
        ->get();
    // Выбираем кандидата с наибольшим совпадением
    $product = $this->bestMatch($normalized, $candidates);
}

// Шаг 3: не нашли → в очередь
if (!$product) {
    $this->queueForReview($name, $icon, $grade, $normalized, $messageId);
    return null;
}
```

**Длина префикса** — вынести в `config/parser.php` как `product_match_prefix_length` (default: 15).

---

## Таблица `products_pending` — очередь новых товаров на проверку

Вместо автоматического создания всех новых товаров сразу в `products` — новые и конфликтные записи попадают в `products_pending`.

**Когда запись попадает в `products_pending`:**
- Парсер встретил название товара, которого нет в `products` → создаём в `products_pending` со статусом `new`
- Парсер встретил известный товар, но с **другой иконкой** (не пустой, а именно другой) → статус `icon_conflict`
- Парсер встретил известный товар, но с **другим грейдом** (не пустым, а именно другим) → статус `grade_conflict`
- Товар найден или создан, но **иконка отсутствует** (ни в объявлении, ни в БД) → статус `missing_icon`
- Товар найден или создан, но **грейд отсутствует** (ни в объявлении, ни в БД), и по типу товара грейд ожидается → статус `missing_grade`

**Поля таблицы `products_pending`:**

| Поле | Описание |
|------|----------|
| `id` | |
| `product_id` | FK на `products` (null если товар новый, не null если конфликт или недостающие данные) |
| `icon` | Иконка из объявления (может быть null) |
| `name` | Название из объявления |
| `normalized_name` | Нормализованное название |
| `grade` | Грейд из объявления (может быть null) |
| `status` | `new` / `icon_conflict` / `grade_conflict` / `missing_icon` / `missing_grade` |
| `tg_message_id` | FK — из какого сообщения пришло |
| `reviewed` | boolean — просмотрено администратором |
| `created_at` / `updated_at` | |

**Действия администратора:**
- `new` → подтвердить (переносится в `products`) / пометить как алиас (заполнить `parent_id`) / удалить как мусор
- `icon_conflict` / `grade_conflict` → решить какое значение правильное, обновить `products` вручную
- `missing_icon` → администратор вручную добавляет иконку в `products`
- `missing_grade` → администратор вручную добавляет грейд в `products`

**TODO в коде:**
- Добавить миграцию для `products_pending`
- В `MessageSaver::saveListing()` изменить логику: вместо `Product::findOrCreateByName()` вызывать новый метод `Product::findOrQueue()` который либо находит существующий товар, либо кладёт в `products_pending` и возвращает null
- Листинги с `product_id = null` (товар на модерации) сохранять с `status = needs_review`
- Добавить Artisan-команду или простой UI для просмотра очереди

---

## Правила обновления записей в `products` при парсинге

При каждом импорте/парсинге нового сообщения — если товар уже есть в БД, обновляем недостающие поля:

| Поле | Логика |
|------|--------|
| `icon` | Если в БД пусто, а в объявлении есть — обновить |
| `grade` | Если в БД пусто, а в объявлении есть — обновить |

Если оба поля уже заполнены в БД — не трогаем, доверяем существующим данным.

Это касается как живого парсинга через MadelineProto, так и импорта через сидеры.

**TODO в коде:** метод `Product::findOrCreateByName()` в `app/Models/Product.php` сейчас обновляет только `icon`. Нужно добавить аналогичную логику для `grade`.

```php
// Текущий код (только icon):
if (!$product->icon && $icon) {
    $product->update(['icon' => $icon]);
}

// Нужно расширить до:
$updates = [];
if (!$product->icon && $icon) $updates['icon'] = $icon;
if (!$product->grade && $grade) $updates['grade'] = $grade;
if (!empty($updates)) $product->update($updates);
```

---

## Парсинг количества товара

Количество товара в объявлении может указываться разными способами:

| Пример | Количество |
|--------|-----------|
| `🥩 Кусок мяса - 358шт 75💰` | 358 |
| `🌳 Дуб - 5шт` | 5 |
| `🌳 Дуб - - 5шт` | 5 (двойной дефис — не ошибка, просто стиль написания) |
| `📦 Сундук - 10 шт` | 10 |
| `🔖 Свиток - 3шт по 1400💰` | 3 |

**Важно:** конструкция вида `Товар - - 5шт` (с двойным дефисом) означает просто "5 штук товара". Двойной дефис — особенность написания некоторых игроков, не нужно интерпретировать как что-то особенное.

**TODO в коде:** в `MessageParser::parseProductLine()` regex для количества должен корректно обрабатывать двойные дефисы и пробелы перед `шт`.

Также при очистке названия товара обязательно убирать **хвостовые символы** после основного имени:

| Символ/паттерн | Пример | Чистое название |
|----------------|--------|-----------------|
| `+` в конце | `Amulet of Sea Depths +` | `Amulet of Sea Depths` |
| `=` в конце | `Безопасный свиток заточки =` | `Безопасный свиток заточки` |
| `/` в конце | `Аксессуар материи /` | `Аксессуар материи` |
| `/шт` в конце | `Кусок мяса /шт` | `Кусок мяса` |
| `\шт` в конце | `Кусок мяса \шт` | `Кусок мяса` |
| `-` / `–` / `—` в конце | `Амарант —` | `Амарант` |
| `:` в конце | `Товар:` | `Товар` |

Эти символы означают что человек не дописал цену или написал "пишите в лс". Они не часть названия товара.

**TODO в коде:** добавить в функцию нормализации финальную очистку:
```php
// После всех остальных очисток — убираем хвостовые мусорные символы
$name = rtrim($name, ' +-=/:–—\\');
$name = preg_replace('/\s*(\/шт|\\\\шт)\s*$/ui', '', $name);
$name = trim($name);
```

---

## Известные ограничения и TODO

- [ ] MadelineProto `messages.getHistory` возвращает сообщения от новых к старым — учитывается в логике offset_id
- [ ] Парсер обменов (`#обмен`) покрывает основной паттерн "Мой X на ваш Y", но нестандартные форматы могут не парситься
- [ ] При первом запуске нет исторических цен → аномалии не определяются (ждём накопления минимум 3 записей)
- [ ] Сидеры с начальными данными ещё не созданы
- [ ] Авторизация MadelineProto должна выполняться интерактивно на сервере (один раз)